---
layout: page
title: About
permalink: /about/
---

I started my programming journey learning C at university. C was what got me hooked on programming. It is such a powerful language, that I felt like I was god. I could write a programme to do pretty much anything, and yes there are complexities around resource management and what not. But as they say, with great power comes great responsibility.

Later on, I taught myself how to programme in PHP. It was the one language to learn at the time as almost every webapp was created in PHP. I appreciated the lack of boiler-plate and the flexibility you get with a dynamically typed language. There is just something quite liberating with being able to open up an interactive prompt and prototyping an algorithm. In the period that I was working quite heavily with PHP, I realised that there is no such thing as a bad language, just bad developers, and I didn't want to be one.

I have a fascination with programming at a low level. I am more excited writing daemonising routines to get a piece of code to background itself, than the rest of the codebase. I find myself moving into backends, sockets, binary protocols, and even character encodings. Eventually, I ended up in the infrastructure world and systems engineering. I thought that knowledge in such areas would bring a more holistic view and complement my skills in software development.

It was also around that time that I started reading about, and getting exposed to devops. It got me thinking about how to better collaborate with teams, how to shorten feedback cycle by choosing the shortest path between two nodes, how to increase productivity by raising visibility of all work in a single view so they can be prioritised against each other and introduce work-in-progress limits. These same principles also influenced how I think about software and systems design. In a highly distributed world, it is important to engineer for simplicity because it is even harder to maintain and remove complexity. Optimising for one piece flow is equally valid for manufacturing, as it is for agile practices and even software systems.

It has been a long way since I wrote my first programme, and there is a much longer journey ahead of me.
